package com.namazustudios.socialengine.model.mission;

import com.namazustudios.socialengine.model.User;
import com.namazustudios.socialengine.model.ValidationGroups.Create;
import com.namazustudios.socialengine.model.ValidationGroups.Insert;
import com.namazustudios.socialengine.model.ValidationGroups.Update;
import io.swagger.annotations.Api;
import io.swagger.annotations.ApiModel;
import io.swagger.annotations.ApiModelProperty;

import javax.validation.constraints.NotNull;
import javax.validation.constraints.Null;
import java.io.Serializable;
import java.util.Map;
import java.util.Objects;

@ApiModel(description = "Represents a Reward that has been issued but has not yet been claimed by the user.  The " +
                        "reward is assigned a unique ID to ensure that it may not have been applied more than once.")
public class RewardIssuance implements Serializable {

    @Null(groups = {Create.class, Insert.class})
    @NotNull(groups = {Update.class})
    @ApiModelProperty("The databased-assigned unique ID of the pending reward.")
    private String id;

    @NotNull
    @ApiModelProperty("The User to receive the reward.")
    private User user;

    @NotNull
    @ApiModelProperty("The state of the reward.")
    private State state;

    @ApiModelProperty("The reward to issue when this pending reward is claimed.")
    private Reward reward;

    @ApiModelProperty("The step that was completed to earn the reward.")
    private Step step;

    @NotNull(groups = {Create.class, Insert.class})
    @Null(groups = {Update.class})
    @ApiModelProperty("A generic String used to uniquely identify the RewardIssuance issuance. If the RewardIssuance is" +
            " created by the client, this value must be specified to prevent erroneous duplicate issuances. E.g. if " +
            "the client successfully submits an issuance but fails to receive the response, the client is expected to" +
            " submit a new issuance with the same context string. Similarly, the client application should have " +
            "safeguards in place in the event of a crash to prevent duplicate submissions: e.g. ensuring that the " +
            "context string is unchanged when performing multiple issuances of the same RewardIssuance. If the " +
            "RewardIssuance is generated by the server, this will be defined automatically. The context cannot be " +
            "updated after creation. Note that an context defined via the API cannot be begin with 'server.' " +
            "as that is a protected namespace.")
    private String context;

    @NotNull(groups={Create.class, Insert.class})
    @Null(groups={Update.class})
    @ApiModelProperty("Defines whether multiple issuances for the given user and context may occur. " +
            "If the type is set to NON_PERSISTENT, at most one ISSUED RewardIssuance may exist in the server at a " +
            "time for a given user and context. " +
            "If the type is set to PERSISTENT, at most one ISSUED or REDEEMED RewardIssuance may exist in the server " +
            "for a given user and context, i.e. once a PERSISTENT RewardIssuance has been submitted, a new one may " +
            "never be submitted and will be rejected by the server. " +
            "Note that this value cannot be updated.")
    private Type type;

    @Null(groups={Create.class, Update.class})
    @ApiModelProperty("Identifies the source of the issuance, e.g. Client, IAP, Leaderboard. This is determined " +
            "automatically by the server and may not be defined or updated by the client.")
    private Source source;

    @ApiModelProperty("Metadata for the issuance. May be optionally defined by the client on creation. If the " +
            "source is a server-side value, then a predefined structure will always be followed that provides" +
            " additional information as to the source of the issuance (e.g. mission progress/step information).")
    private Map<String, Object> metadata;

    @ApiModelProperty("Optionally define when the issuance should expire. This value may be updated to extend " +
            "when the expiration occurs. When set, this value must be greater than the current time on the server.")
    private Long expirationTimestamp;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public Step getStep() {
        return step;
    }

    public void setStep(Step step) {
        this.step = step;
    }

    public Reward getReward() {
        return reward;
    }

    public void setReward(Reward reward) {
        this.reward = reward;
    }

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

    public Source getSource() {
        return source;
    }

    public void setSource(Source source) {
        this.source = source;
    }

    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public Map<String, Object> getMetadata() {
        return metadata;
    }

    public void setMetadata(Map<String, Object> metadata) {
        this.metadata = metadata;
    }

    public Long getExpirationTimestamp() {
        return expirationTimestamp;
    }

    public void setExpirationTimestamp(Long expirationTimestamp) {
        this.expirationTimestamp = expirationTimestamp;
    }


    @Override
    public boolean equals(Object object) {
        if (this == object) return true;
        if (!(object instanceof RewardIssuance)) return false;
        RewardIssuance that = (RewardIssuance) object;
        return Objects.equals(getId(), that.getId()) &&
                Objects.equals(getUser(), that.getUser()) &&
                getState() == that.getState() &&
                Objects.equals(getReward(), that.getReward()) &&
                Objects.equals(getStep(), that.getStep()) &&
                Objects.equals(getContext(), that.getContext()) &&
                getSource() == that.getSource() &&
                getType() == that.getType() &&
                Objects.equals(getMetadata(), that.getMetadata()) &&
                Objects.equals(getExpirationTimestamp(), that.getExpirationTimestamp());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getId(), getUser(), getState(), getReward(), getStep(),
                getContext(), getSource(), getType(), getMetadata(), getExpirationTimestamp());
    }

    @Override
    public String toString() {
        return "RewardIssuance{" +
                "id='" + id + '\'' +
                ", user=" + user +
                ", state=" + state +
                ", reward=" + reward +
                ", step=" + step +
                ", context=" + context +
                ", source=" + source +
                ", type=" + type +
                ", metadata=" + metadata +
                ", expirationTimestamp=" + expirationTimestamp +
                '}';
    }

    public enum State {
        /**
         * Indicates that the RewardIssuance has been successfully issued but not yet redeemed by the client.
         */
        ISSUED,

        /**
         * Indicates that the RewardIssuance has been successfully redeemed. If the RewardIssuance has a NON_PERSISTENT
         * Type, then, after a successful redemption, the {@Link MongoRewardIssuanceDao} will immediately attempt
         * to delete the RewardIssuance.
         *
         * TODO: since we cannot guarantee the reward issuance to a user and deleting a PERSISTENT RewardIssuance since
         * TODO: mongo does not support transactions, we may need some scheduled cleanup process to clear them out
         * TODO: (setting a new expiration date will not work since that likewise cannot be done atomically).
         *
         */
        REDEEMED
    }

    public enum Source {
        /**
         * Indicates that the source of the RewardIssuance was from the client code.
         */
        CLIENT,

        /**
         * Indicates that the source of the RewardIssuance was from MissionProgress (server-side).
         */
        MISSION_PROGRESS,

        /**
         * Indicates that the source of the RewardIssuance was from an IAP (server-side).
         */
        IAP,    // unused for now

        /**
         * Indicates that the source of the RewardIssuance was from a Leaderboard achievement (server-side).
         */
        LEADERBOARD // unused for now
    }

    public enum Type {
        /**
         * Indicates that the RewardIssuance may only be issued once per user per context, even after the
         * redemption step (i.e. there may only ever be at most one RewardIssuance that is either ISSUED or REDEEMED).
         * If set, the system will ignore the expirationTimestamp and the record will remain persisted to prevent
         * future issuances.
         *
         */
        PERSISTENT,

        /**
         * Indicates that the RewardIssuance may be issued repeatedly to the same user with the same context.
         * Note that only one RewardIssuance in the ISSUED state may exist at a time, i.e. any pre-existing RewardIssuance
         * with a matching user and context must either first expire or be redeemed before a new RewardIssuance
         * will be created.
         */
        NON_PERSISTENT
    }
}
