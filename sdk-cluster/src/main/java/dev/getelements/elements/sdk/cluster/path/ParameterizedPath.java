package dev.getelements.elements.sdk.cluster.path;

import java.io.Serializable;
import java.util.Iterator;
import java.util.LinkedHashMap;
import java.util.List;
import java.util.Map;
import java.util.function.Function;

import static java.util.Collections.unmodifiableList;
import static java.util.function.Function.identity;
import static java.util.stream.Collectors.*;

/**
 * Similar to {@link Path}, but supports the parsing of parameters to the path.  Final {@link Path}
 * instances may be generated by applying the parameters specified.
 *
 * Created by patricktwohig on 8/16/17.
 */
public final class ParameterizedPath implements Serializable {

    private static final String OPEN_PARAMETER = "{";

    private static final String CLOSE_PARAMETER = "}";

    private final Path raw;

    private final List<String> parameters;

    /**
     * Builds this {@link ParameterizedPath} from the supplied raw string.
     *
     * This uses {@link Path#Path(String)}
     *
     * @param path the unparsed path
     */
    public ParameterizedPath(final String path) {
        this(new Path(path));
    }

    /**
     * Builds this {@link ParameterizedPath} from the supplied components.
     *
     * This uses {@link Path#Path(List)}
     *
     * @param components the list of path components
     */
    public ParameterizedPath(final List<String> components) {
        this(new Path(components));
    }

    /**
     * Creates a new {@link ParameterizedPath} instance from the supplied {@link Path}
     *
     * @param raw the raw path
     * @throws  IllegalArgumentException if {@link Path#isWildcard()} returns true, or if parameters are duplicated
     */
    public ParameterizedPath(final Path raw) {

        this.raw = raw;

        if (raw.isWildcard()) {
            throw new IllegalArgumentException(raw + " must not be wildcard");
        }

        final List<String> parameters = getRaw().getComponents()
            .stream()
            .filter(this::isParameter)
            .map(c -> c.substring(1, c.length() - 1))
            .collect(toList());

        final Map<String, Long> counts = parameters
            .stream()
            .collect(groupingBy(identity(), counting()));

        parameters.forEach(p ->  {

            final long count = counts.getOrDefault(p, 0l);

            if (count > 1) {
                throw new IllegalArgumentException("Parameter " + p + " appears " + count + " " + parameters);
            }

        });

        this.parameters = unmodifiableList(parameters);

    }

    /**
     * Gets the underlying raw {@link Path} instance.
     *
     * @return the {@link Path} instance
     */
    public Path getRaw() {
        return raw;
    }

    /**
     * Gets the components of the underlying {@link Path} which are parameterized.
     *
     * @return a listing of all parameters, stripped of the curly braces
     */
    public List<String> getParameters() {
        return parameters;
    }

    /**
     * Resolves all parameters in this {@link ParameterizedPath} with the supplied mapping
     * of parameters.
     *
     * @param parameters the parameters map
     * @return a fully resolved {@link Path}
     */
    public Path resolve(final Map<String, String> parameters) {
        return resolve(parameters::get);
    }

    /**
     * Resolves this instance against the supplied {@link Function<String, String>} which provides a
     * mapping of parameters to their values.
     *
     * @param resolver the resolver, which may return null if the parameter is unresolved.
     * @return the resolved {@link Path} instance, never null
     *
     * @throws IllegalArgumentException if the supplied resolver cannot resolve the parameters
     */
    public Path resolve(final Function<String, String> resolver) {

        final Function<String, String> wrapped = resolver.andThen(component -> {

            if (component == null) {
                throw new IllegalArgumentException("could not resolve " + component);
            }

            return component;

        });

        final List<String> components = getRaw().getComponents()
                .stream()
                .map(c -> isParameter(c) ? wrapped.apply(c) : c)
                .collect(toList());

        return new Path(components);

    }

    /**
     * Checks if this {@link ParameterizedPath} matches the supplied {@link Path}.  A {@link Path} matches this
     * {@link ParameterizedPath} if it has the same number of components and each component is equal to the
     * patch or corresponds to a parameter.
     *
     * @param path the {@link Path}
     * @return true if this {@link Path} matches
     */
    public boolean matches(final Path path) {

        if (path.getComponents().size() != raw.getComponents().size()) {
            return false;
        }

        final Iterator<String> pathComponents = path.getComponents().iterator();

        return raw.getComponents()
            .stream()
            .allMatch(c -> c.equals(pathComponents.next()) || isParameter(c));

    }

    /**
     * Given the provided non-parameterized path, this will return a {@link Map<String, String>} of the value of the
     * parameters.  The supplied {@link Path} must match this instance using {@link #matches(Path)} for this method to
     * succeed.
     *
     * The ordering of the returned {@link Map<String, String>} will be returned in the order in which the mapping
     * matched the original {@link Path}.
     *
     * @param path the {@link Path} which matches this
     * @return the mapping of parameter names to the supplied {@link Path}
     *
     * @throws IllegalArgumentException if the {@link Path} does not match
     */
    public Map<String, String> extract(final Path path) {

        if (!matches(path)) {
            throw new IllegalArgumentException(path + " does not match " + this);
        }

        final Map<String, String> extraced = new LinkedHashMap<>();

        final Iterator<String> parameters = getParameters().iterator();

        final Iterator<String> rawComponents = getRaw().getComponents().iterator();
        final Iterator<String> pathComponents = path.getComponents().iterator();

        while (rawComponents.hasNext() && pathComponents.hasNext()) {

            final String rawComponent = rawComponents.next();
            final String pathComponent = pathComponents.next();

            if (isParameter(rawComponent)) {
                extraced.put(parameters.next(), pathComponent);
            }

        }

        return extraced;

    }

    private boolean isParameter(final String component) {
        return component.startsWith(OPEN_PARAMETER) && component.endsWith(CLOSE_PARAMETER);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof ParameterizedPath)) return false;

        ParameterizedPath that = (ParameterizedPath) o;

        return getRaw().equals(that.getRaw());
    }

    @Override
    public int hashCode() {
        return getRaw().hashCode();
    }

    @Override
    public String toString() {
        return "ParameterizedPath{" +
                "raw=" + raw +
                ", parameters=" + parameters +
                '}';
    }

}
