package dev.getelements.elements.sdk.model.reward;

import dev.getelements.elements.sdk.model.Taggable;
import dev.getelements.elements.sdk.model.user.User;
import dev.getelements.elements.sdk.model.ValidationGroups.Create;
import dev.getelements.elements.sdk.model.ValidationGroups.Insert;
import dev.getelements.elements.sdk.model.ValidationGroups.Update;
import dev.getelements.elements.sdk.model.goods.Item;
import dev.getelements.elements.sdk.model.mission.Step;
import io.swagger.v3.oas.annotations.media.Schema;


import jakarta.validation.constraints.NotNull;
import jakarta.validation.constraints.Null;
import java.io.Serializable;
import java.util.*;

@Schema(description = "Represents a Reward that has been issued but has not yet been claimed by the user.  The " +
                      "reward is assigned a unique ID to ensure that it may not have been applied more than once.")
public class RewardIssuance implements Serializable, Taggable {

    public static final String SERVER_CONTEXT_PREFIX = "SERVER";

    public static final String CONTEXT_SEPARATOR = ".";

    public static final String MISSION_PROGRESS_SOURCE = "MISSION_PROGRESS";

    public static final String APPLE_IAP_SOURCE = "APPLE_IAP";

    public static final String GOOGLE_PLAY_IAP_SOURCE = "GOOGLE_PLAY_IAP";

    public static final String FACEBOOK_IAP_SOURCE = "FACEBOOK_IAP";

    public static final String OCULUS_IAP_SOURCE = "OCULUS_IAP";

    public static final String MISSION_PROGRESS_PROGRESS_KEY = "progress";

    public static final String MISSION_PROGRESS_STEP_KEY = "step";

    @Null(groups = {Create.class})
    @NotNull(groups = {Update.class})
    @Schema(description = "The unique ID of the issuance.")
    private String id;

    @NotNull
    @Schema(description = "The User to receive the reward.")
    private User user;

    @Null(groups={Create.class, Update.class})
    @NotNull
    @Schema(description = "The state of the reward. On creation, this is automatically assigned to be ISSUED. If the " +
            "current value of the state is REDEEMED, then the state is no longer allowed to be updated. This value" +
            "may not be directly modified--the redeem DAO method should be used instead to perform the redemption " +
            "process.")
    private State state;

    @Schema(description = "The Item to be issued upon redemption.")
    private Item item;

    @Schema(description = "The amount of Items to be set/added to the InventoryItem upon redemption.")
    private Integer itemQuantity;

    @NotNull(groups = {Create.class, Insert.class})
    @Null(groups = {Update.class})
    @Schema(description = "A generic String used to uniquely identify the RewardIssuance issuance. If the RewardIssuance is" +
            " created by the client, this value must be specified to prevent erroneous duplicate issuances. E.g. if " +
            "the client successfully submits an issuance but fails to receive the response, the client is expected to" +
            " submit a new issuance with the same context string. Similarly, the client application should have " +
            "safeguards in place in the event of a crash to prevent duplicate submissions: e.g. ensuring that the " +
            "context string is unchanged when performing multiple issuances of the same RewardIssuance. If the " +
            "RewardIssuance is generated by the server, this will be defined automatically. The context cannot be " +
            "updated after creation. Note that an context defined via the API should not begin with 'server.' " +
            "as that is a protected namespace.")
    private String context;

    @NotNull(groups={Create.class, Insert.class})
    @Null(groups={Update.class})
    @Schema(description = "Defines whether multiple issuances for the given user+reward+context may occur. " +
            "If the type is set to NON_PERSISTENT, at most one ISSUED RewardIssuance may exist in the server at a " +
            "time for a given user and context. " +
            "If the type is set to PERSISTENT, at most one ISSUED or REDEEMED RewardIssuance may exist in the server " +
            "for a given user and context, i.e. once a PERSISTENT RewardIssuance has been submitted, a new one may " +
            "never be submitted and will be rejected by the server. " +
            "Note that this value cannot be updated. By default, this will be set to NON_PERSISTENT.")
    private Type type;

    @Null(groups={Update.class})
    @Schema(description = "Identifies the source of the issuance, e.g. 'Client', 'IAP', 'Leaderboard'. This may be " +
            "specified manually by the client if desired. Note that this value cannot be updated.")
    private String source;

    @Schema(description = "Metadata for the issuance. May be optionally defined by the client on creation. If the " +
            "source is a server-side value, then a predefined structure will always be followed that provides" +
            " additional information as to the source of the issuance (e.g. mission progress/step information).")
    private Map<String, Object> metadata;

    @Schema(description = "The tags used to categorize this Reward Issuance.")
    private List<String> tags;

    @Schema(description = "Optionally define when the issuance should expire. This value may be updated to extend " +
            "when the expiration occurs. When set, this value must be greater than the current time on the server." +
            "Note that the record may not actually be deleted for up to sixty seconds after the time noted in the" +
            "timestamp.")
    private Long expirationTimestamp;

    @Null(groups={Create.class, Update.class})
    @Schema(description = "Internal unique identifier generated and assigned on creation.")
    private String uuid;

    public String getId() {
        return id;
    }

    public void setId(String id) {
        this.id = id;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public Item getItem() {
        return item;
    }

    public void setItem(Item item) {
        this.item = item;
    }

    public Integer getItemQuantity() {
        return itemQuantity;
    }

    public void setItemQuantity(Integer itemQuantity) {
        this.itemQuantity = itemQuantity;
    }

    public State getState() {
        return state;
    }

    public void setState(State state) {
        this.state = state;
    }

    public String getContext() {
        return context;
    }

    public void setContext(String context) {
        this.context = context;
    }

    public String getSource() {
        return source;
    }

    public void setSource(String source) {
        this.source = source;
    }

    public Type getType() {
        return type;
    }

    public void setType(Type type) {
        this.type = type;
    }

    public Map<String, Object> getMetadata() {
        return metadata;
    }

    public void setMetadata(Map<String, Object> metadata) {
        this.metadata = metadata;
    }

    public void addMetadata(final String name, final Object value) {

        if (getMetadata() == null) {
            setMetadata(new HashMap<>());
        }

        getMetadata().put(name, value);

    }

    public Long getExpirationTimestamp() {
        return expirationTimestamp;
    }

    public void setExpirationTimestamp(Long expirationTimestamp) {
        this.expirationTimestamp = expirationTimestamp;
    }

    public String getUuid() {
        return uuid;
    }

    public void setUuid(String uuid) {
        this.uuid = uuid;
    }

    public List<String> getTags() {
        return tags;
    }

    public void setTags(List<String> tags) {
        this.tags = tags;
    }

    public void addTag(final String tag) {
        if (getTags() == null) {
            setTags(new ArrayList<>());
        }

        getTags().add(tag);
    }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (o == null || getClass() != o.getClass()) return false;
        RewardIssuance that = (RewardIssuance) o;
        return Objects.equals(getId(), that.getId()) &&
                Objects.equals(getUser(), that.getUser()) &&
                getState() == that.getState() &&
                Objects.equals(getItem(), that.getItem()) &&
                Objects.equals(getItemQuantity(), that.getItemQuantity()) &&
                Objects.equals(getContext(), that.getContext()) &&
                getType() == that.getType() &&
                Objects.equals(getSource(), that.getSource()) &&
                Objects.equals(getMetadata(), that.getMetadata()) &&
                Objects.equals(getTags(), that.getTags()) &&
                Objects.equals(getExpirationTimestamp(), that.getExpirationTimestamp()) &&
                Objects.equals(getUuid(), that.getUuid());
    }

    @Override
    public int hashCode() {
        return Objects.hash(getId(), getUser(), getState(), getItem(), getItemQuantity(),
                getContext(), getType(), getSource(), getMetadata(), getTags(), getExpirationTimestamp(),
                getUuid());
    }

    @Override
    public String toString() {
        return "RewardIssuance{" +
                "id='" + id + '\'' +
                ", user=" + user +
                ", state=" + state +
                ", item=" + item +
                ", itemQuantity=" + itemQuantity +
                ", context='" + context + '\'' +
                ", type=" + type +
                ", source='" + source + '\'' +
                ", metadata=" + metadata +
                ", tags=" + tags +
                ", expirationTimestamp=" + expirationTimestamp +
                ", uuid='" + uuid + '\'' +
                '}';
    }

    public enum State {
        /**
         * Indicates that the RewardIssuance has been successfully issued but not yet redeemed by the client. This is
         * the default value of an issuance when created.
         */
        ISSUED,

        /**
         * Indicates that the RewardIssuance has been successfully redeemed. If the RewardIssuance has a NON_PERSISTENT
         * Type, then, after a successful redemption, the MongoRewardIssuanceDao will immediately attempt
         * to delete the RewardIssuance.
         *
         * TODO: since we cannot guarantee that we will both successfully redeem a NON_PERSISTENT RewardIssuance and
         * TODO: successfully delete it since mongo does not support transactions, we may need some scheduled cleanup
         * TODO: process to clear them out (setting a new expiration date will not work since that
         * TODO: likewise cannot be done atomically).
         *
         */
        REDEEMED
    }

    public enum Type {
        /**
         * Indicates that the RewardIssuance may only be issued once per user per context, even after the
         * redemption step (i.e. there may only ever be at most one RewardIssuance that is either ISSUED or REDEEMED).
         * If set, the system will ignore the expirationTimestamp and the record will remain persisted to prevent
         * future issuances.
         *
         */
        PERSISTENT,

        /**
         * Indicates that the RewardIssuance may be issued repeatedly to the same user with the same context.
         * Note that only one RewardIssuance in the ISSUED state may exist at a time, i.e. any pre-existing RewardIssuance
         * with a matching user and context must either first expire or be redeemed before a new RewardIssuance
         * will be created.
         */
        NON_PERSISTENT
    }

    public static String buildContextString(Object ... contextComponents) {
        final StringBuilder stringBuilder = new StringBuilder();
        for (int i = 0; i < contextComponents.length; i++) {
            Object contextComponent = contextComponents[i];
            stringBuilder.append(contextComponent.toString());
            if (i < contextComponents.length - 1) {
                stringBuilder.append(CONTEXT_SEPARATOR);
            }
        }

        return stringBuilder.toString();
    }

    /**
     * Builds the context string for a Mission Progression-sourced reward issuance. The last elements in the context
     * string are, respectively, the {@param progressId}, the {@param sequence} that caused the issuance, and the
     * {@param rewardIndex} of the current reward in the {@link Step}'s list of {@link Reward}s.
     *
     * @param progressId
     * @param sequence
     * @param rewardIndex
     * @return the resultant context string
     */
    public static String buildMissionProgressContextString(String progressId, int sequence, int rewardIndex) {
        return buildContextString(
                SERVER_CONTEXT_PREFIX,
                MISSION_PROGRESS_SOURCE,
                progressId,
                Integer.toString(sequence),
                Integer.toString(rewardIndex));
    }

    /**
     * Builds the context string for a Mission Progression-sourced reward issuance. The last elements in the context
     * string are, respectively, the {@param progressId}, the {@param sequence} that caused the issuance, and the
     * {@param rewardIndex} of the current reward in the {@link Step}'s list of {@link Reward}s.
     *
     * @param progressId
     * @param sequence
     * @param rewardIndex
     * @return the resultant context string
     */
    public static String buildMissionProgressContextString(String progressId, String sequence, String rewardIndex) {
        return buildContextString(SERVER_CONTEXT_PREFIX, MISSION_PROGRESS_SOURCE, progressId, sequence, rewardIndex);
    }

    /**
     * Builds the context string for an Apple IAP-sourced reward issuance. The last element in the context string is
     * a hash of the {@param originalTransactionId}, the {@param itemId}, as well as the {@param skuOrdinal},
     * i.e. the index of the product as enumerated in SKPayment.quantity (i.e. the "first" SKU to be redeemed, the
     * "second" to be redeemed, etc.).
     *
     * @param originalTransactionId
     * @param itemId
     * @param skuOrdinal
     * @return the resultant context string
     */
    public static String buildAppleIapContextString(
            final String originalTransactionId,
            final String itemId,
            final Integer skuOrdinal
    ) {
        final int hashResult = Objects.hash(originalTransactionId, itemId, skuOrdinal);
        final String hashResultString = Integer.toString(hashResult);
        return buildContextString(
                SERVER_CONTEXT_PREFIX,
                APPLE_IAP_SOURCE,
                hashResultString
        );

    }

    /**
     * Builds the context string for a Google Play-sourced reward issuance. The last element in the context string is
     * the hash of the orderId issued by the Google Play services, presumed to be universally unique, as well as the
     * itemId.
     *
     * @param orderId
     * @param itemId
     * @return the resultant context string
     */
    public static String buildGooglePlayIapContextString(String orderId, String itemId) {
        final int hashResult = Objects.hash(orderId, itemId);
        final String hashResultString = Integer.toString(hashResult);
        return buildContextString(SERVER_CONTEXT_PREFIX, GOOGLE_PLAY_IAP_SOURCE, hashResultString);
    }

    /**
     * Builds the context string for a Facebook-sourced reward issuance. The last element in the context string is
     * the hash of the orderId issued by the Facebook services, presumed to be universally unique, as well as the
     * itemId.
     *
     * @param orderId
     * @param itemId
     * @return the resultant context string
     */
    public static String buildFacebookIapContextString(String orderId, String itemId) {
        final int hashResult = Objects.hash(orderId, itemId);
        final String hashResultString = Integer.toString(hashResult);
        return buildContextString(SERVER_CONTEXT_PREFIX, FACEBOOK_IAP_SOURCE, hashResultString);
    }

    /**
     * Builds the context string for a Oculus-sourced reward issuance. The last element in the context string is
     * the hash of the orderId issued by the Facebook services, presumed to be universally unique, as well as the
     * itemId.
     *
     * @param orderId
     * @param itemId
     * @return the resultant context string
     */
    public static String buildOculusIapContextString(String orderId, String itemId) {
        final int hashResult = Objects.hash(orderId, itemId);
        final String hashResultString = Integer.toString(hashResult);
        return buildContextString(SERVER_CONTEXT_PREFIX, OCULUS_IAP_SOURCE, hashResultString);
    }
}
